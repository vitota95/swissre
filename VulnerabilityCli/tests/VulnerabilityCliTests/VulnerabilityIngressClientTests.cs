using System;
using System.IO;
using System.Net;
using System.Net.Http;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using AutoFixture;
using Moq;
using Moq.Protected;
using NUnit.Framework;
using VulnerabilityCli.Application;
using VulnerabilityCli.Models;

namespace VulnerabilityCliTests;

[TestFixture]
public class VulnerabilityIngressClientTests
{
    private Mock<IHttpClientFactory> _httpClientFactoryMock;
    private Mock<HttpMessageHandler> _httpMessageHandlerMock;
    private StringWriter _consoleOutput;
    private Fixture _fixture;

    [SetUp]
    public void Setup()
    {
        _httpClientFactoryMock = new Mock<IHttpClientFactory>();
        _httpMessageHandlerMock = new Mock<HttpMessageHandler>();
        _fixture = new Fixture();

        // Redirect console output to a StringWriter for testing
        _consoleOutput = new StringWriter();
        Console.SetOut(_consoleOutput);

    }

    [TearDown]
    public void TearDown()
    {
        // Reset the console output
        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = true });
        _consoleOutput.Dispose();
    }

    [Test]
    public async Task PostVulnerabilityDataAsync_WhenResponseIsSuccess_ShouldLogSuccessMessage()
    {
        // Arrange
        var vulnerabilityData = _fixture.Create<VulnerabilityData>();

        var httpResponse = new HttpResponseMessage
        {
            StatusCode = HttpStatusCode.OK
        };

        _httpMessageHandlerMock
            .Protected()
            .Setup<Task<HttpResponseMessage>>(
                "SendAsync",
                ItExpr.IsAny<HttpRequestMessage>(),
                ItExpr.IsAny<CancellationToken>())
            .ReturnsAsync(httpResponse);

        var httpClient = new HttpClient(_httpMessageHandlerMock.Object);
        _httpClientFactoryMock.Setup(factory => factory.CreateClient(It.IsAny<string>())).Returns(httpClient);

        var client = new VulnerabilityIngressClient(_httpClientFactoryMock.Object);

        // Act
        await client.PostVulnerabilityDataAsync(vulnerabilityData, "https://example.com");

        // Assert
        _httpMessageHandlerMock.Protected().Verify(
            "SendAsync",
            Times.Once(),
            ItExpr.Is<HttpRequestMessage>(req =>
                req.Method == HttpMethod.Post &&
                req.RequestUri == new Uri("https://example.com/vulnerability")),
            ItExpr.IsAny<CancellationToken>());
        var output = _consoleOutput.ToString();
        Assert.That(output, Does.Contain("Vulnerability data posted successfully to https://example.com/vulnerability."));
    }

    [Test]
    public void PostVulnerabilityDataAsync_WhenResponseIsBadRequest_ShouldLogErrorMessage()
    {
        // Arrange
        var vulnerabilityData = _fixture.Create<VulnerabilityData>();

        var httpResponse = new HttpResponseMessage
        {
            StatusCode = HttpStatusCode.BadRequest
        };

        _httpMessageHandlerMock
            .Protected()
            .Setup<Task<HttpResponseMessage>>(
                "SendAsync",
                ItExpr.IsAny<HttpRequestMessage>(),
                ItExpr.IsAny<CancellationToken>())
            .ReturnsAsync(httpResponse);

        var httpClient = new HttpClient(_httpMessageHandlerMock.Object);
        _httpClientFactoryMock.Setup(factory => factory.CreateClient(It.IsAny<string>())).Returns(httpClient);

        var client = new VulnerabilityIngressClient(_httpClientFactoryMock.Object);

        // Act & Assert
        var ex = Assert.ThrowsAsync<InvalidOperationException>(async () =>
            await client.PostVulnerabilityDataAsync(vulnerabilityData, "https://example.com"));

        Assert.That(ex.Message, Is.EqualTo("Bad Request: The server could not understand the request."));
        var output = _consoleOutput.ToString();
        Assert.That(output, Does.Contain("Failed to post vulnerability data. Status code: BadRequest"));
    }

    [Test]
    public void PostVulnerabilityDataAsync_WhenResponseIsNotFound_ShouldLogErrorMessage()
    {
        // Arrange
        var vulnerabilityData = _fixture.Create<VulnerabilityData>();

        var httpResponse = new HttpResponseMessage
        {
            StatusCode = HttpStatusCode.NotFound
        };

        _httpMessageHandlerMock
            .Protected()
            .Setup<Task<HttpResponseMessage>>(
                "SendAsync",
                ItExpr.IsAny<HttpRequestMessage>(),
                ItExpr.IsAny<CancellationToken>())
            .ReturnsAsync(httpResponse);

        var httpClient = new HttpClient(_httpMessageHandlerMock.Object);
        _httpClientFactoryMock.Setup(factory => factory.CreateClient(It.IsAny<string>())).Returns(httpClient);

        var client = new VulnerabilityIngressClient(_httpClientFactoryMock.Object);

        // Act & Assert
        var ex = Assert.ThrowsAsync<HttpRequestException>(async () =>
            await client.PostVulnerabilityDataAsync(vulnerabilityData, "https://example.com"));

        Assert.That(ex.Message, Is.EqualTo("Not Found: The endpoint does not exist."));

        var output = _consoleOutput.ToString();
        Assert.That(output, Does.Contain("Failed to post vulnerability data. Status code: NotFound"));
    }
}